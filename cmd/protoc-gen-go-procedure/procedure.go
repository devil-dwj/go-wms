package main

import (
	"bytes"
	"fmt"
	"strconv"
	"strings"
	"unicode"

	"google.golang.org/protobuf/compiler/protogen"
)

const (
	gormPackage    = protogen.GoImportPath("gorm.io/gorm")
	contextPackage = protogen.GoImportPath("context")
)

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {

	filename := file.GeneratedFilenamePrefix + ".procedure.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-procedure. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	generateFileContent(gen, file, g)

	return g
}

func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if len(file.Messages) == 0 {
		return
	}

	origFileName := file.Proto.GetName()
	trimName := strings.TrimSuffix(origFileName, "_pr.proto")
	goTypeName := CamelCase(trimName)
	goStructName := goTypeName + "Procedure"

	// interface
	g.P("type ", goStructName, " interface {")
	g.P("GetRawDB() *", gormPackage.Ident("DB"))
	for _, message := range file.Messages {
		if !genable(string(message.Desc.Name())) {
			continue
		}

		g.P(interfaceSignature(gen, file, g, message))
	}
	g.P("}")
	g.P()

	// struct impl
	goStructImplName := goTypeName + "_Procedure"
	g.P("type ", goStructImplName, " struct {")
	g.P("db *", gormPackage.Ident("DB"))
	g.P("}")

	// new
	g.P("func New", goStructName, "(db *", gormPackage.Ident("DB"), ") ", goStructName, "{")
	g.P("return &", goStructImplName, "{db: db}")
	g.P("}")
	g.P()

	// GetRawDB
	g.P("func ", getEnclosureIdent(goStructImplName), "GetRawDB() *", gormPackage.Ident("DB"), "{")
	g.P("return r.db")
	g.P("}")
	g.P()

	// impl methods
	for _, message := range file.Messages {
		if !genable(string(message.Desc.Name())) {
			continue
		}

		implFuncSignature(gen, file, g, message, goStructImplName)
	}
}

func interfaceSignature(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, message *protogen.Message) string {
	var req = ""
	var rsp = ""
	var result = ""
	var total = ""
	var totalPage = ""
	var pageTotal = ""
	for _, field := range message.Fields {
		if field.GoName == "Req" && field.Message != nil {
			req = "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		}
		if field.GoName == "Rsp" && field.Message != nil {
			rsp = "[]*" + g.QualifiedGoIdent(field.Message.GoIdent) + ", "
		}
		if field.GoName == "Result" {
			result = "int" + ", "
		}
		if field.GoName == "TotalCount" {
			total = "int, "
		}
		if field.GoName == "TotalPage" {
			totalPage = "int, "
		}
		if field.GoName == "PageTotal" {
			pageTotal = "int, "
		}
	}

	return message.GoIdent.GoName + "(" + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ", " + req + ") (" + rsp + result + total + totalPage + pageTotal + "error)"
}

func implFuncSignature(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, message *protogen.Message, goStructImplName string) {

	var req = ""
	var rsp = ""
	var result = ""
	var total = ""
	var totalPage = ""
	var pageTotal = ""
	for _, field := range message.Fields {

		if field.GoName == "Req" && field.Message != nil {
			req = "req *" + g.QualifiedGoIdent(field.Message.GoIdent)
		}
		if field.GoName == "Rsp" && field.Message != nil {
			rsp = "[]*" + g.QualifiedGoIdent(field.Message.GoIdent) + ", "
		}
		if field.GoName == "Result" {
			result = "int" + ", "
		}
		if field.GoName == "TotalCount" {
			total = "int, "
		}
		if field.GoName == "TotalPage" {
			totalPage = "int, "
		}
		if field.GoName == "PageTotal" {
			pageTotal = "int, "
		}
	}

	g.P("func ", getEnclosureIdent(goStructImplName), message.GoIdent.GoName, "(ctx context.Context, ", req, ") (", rsp, result, total, totalPage, pageTotal, "error) {")
	// call prps
	callPrpsSignature(gen, file, g, message)
	g.P("}")
	g.P()
}

func callPrpsSignature(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, message *protogen.Message) {

	var (
		resIdent       = ""
		resultIdent    = ""
		totalIdent     = ""
		totalPageIdent = ""
		pageTotalIdent = ""

		returnRes       = ""
		returnResult    = ""
		returnTotal     = ""
		returnTotalPage = ""
		returnPageTotal = ""
	)

	for _, field := range message.Fields {

		if field.GoName == "Rsp" && field.Message != nil {
			resIdent = fmt.Sprintf("res := []*%s{}", g.QualifiedGoIdent(field.Message.GoIdent))
			returnRes = "res, "
		}

		if field.GoName == "Result" {
			resultIdent = "result := -1"
			returnResult = "result, "
		}

		if field.GoName == "TotalCount" {
			totalIdent = "total := 0"
			returnTotal = "total, "
		}

		if field.GoName == "TotalPage" {
			totalPageIdent = "totalPage := 0"
			returnTotalPage = "totalPage, "
		}

		if field.GoName == "PageTotal" {
			pageTotalIdent = "pageTotal := 0"
			returnPageTotal = "pageTotal, "
		}
	}

	g.P(resIdent)
	g.P(resultIdent)
	g.P(totalIdent)
	g.P(totalPageIdent)
	g.P(pageTotalIdent)

	g.P("tx := r.db.WithContext(ctx).Begin()")
	g.P("err := tx.")

	// iv field
	ivTempl := ""
	ivTotal := ""
	ivTotalPage := ""
	ivPageTotal := ""
	ivArg := ""
	ivComma := ""
	for _, field := range message.Fields {
		if field.GoName == "Req" {
			ivComma = ","
			fieldLen := len(field.Message.Fields)
			for i, field1 := range field.Message.Fields {
				ide := ", "
				if i == fieldLen-1 {
					ide = ""
				}

				ivTempl += ", ?"
				ivArg += fmt.Sprintf("req.%s%s",
					CamelCase(field1.GoName), ide)
			}
		}

		if field.GoName == "TotalCount" {
			ivTotal += ", @ov_total_count"
		}
		if field.GoName == "TotalPage" {
			ivTotalPage += ", @ov_total_page"
		}
		if field.GoName == "PageTotal" {
			ivPageTotal += ", @ov_page_total"
		}
	}

	if ivTempl != "" {
		// 有入参
		g.P(fmt.Sprintf(`Raw("call %s(@ov_return%s%s%s%s)"%s`,
			SnakeCase(message.GoIdent.GoName), ivTempl, ivTotal, ivTotalPage, ivPageTotal, ivComma))
		g.P(fmt.Sprintf("%s).", ivArg))
		if resIdent != "" {
			g.P("Scan(&res).")
		} else {
			if resultIdent == "" {
				g.P("result := -1")
			}
			g.P("Scan(&result).")
		}

		if resultIdent != "" {
			g.P(`Raw("select @ov_return").`)
			g.P("Scan(&result).")
		}
		if totalIdent != "" {
			g.P(`Raw("select @ov_total_count").`)
			g.P("Scan(&total).")
		}
		if totalPageIdent != "" {
			g.P(`Raw("select @ov_total_page").`)
			g.P("Scan(&totalPage).")
		}
		if pageTotalIdent != "" {
			g.P(`Raw("select @ov_page_total").`)
			g.P("Scan(&pageTotal).")
		}

	} else {
		// 无入参
		g.P(fmt.Sprintf(`Raw("call %s(@ov_return%s)").`,
			SnakeCase(message.GoIdent.GoName), ivTotal))
		if resIdent != "" {
			g.P("Scan(&res).")
		}
		if resultIdent != "" {
			g.P(`Raw("select @ov_return").`)
			g.P("Scan(&result).")
		}
		if totalIdent != "" {
			g.P(`Raw("select @ov_total_count").`)
			g.P("Scan(&total).")
		}
		if totalPageIdent != "" {
			g.P(`Raw("select @ov_total_page").`)
			g.P("Scan(&totalPage).")
		}
		if pageTotalIdent != "" {
			g.P(`Raw("select @ov_page_total").`)
			g.P("Scan(&pageTotal).")
		}
	}

	g.P("Error")
	g.P()

	g.P("if err != nil {")
	g.P("tx.Rollback()")
	g.P("} else {")
	g.P("err = tx.Commit().Error")
	g.P("}")
	g.P()

	g.P(fmt.Sprintf("return %s%s%s%s%serr", returnRes, returnResult, returnTotal, returnTotalPage, returnPageTotal))
}

func getEnclosureIdent(name string) string {
	return "(r *" + name + ")"
}

func genable(name string) bool {
	return strings.HasPrefix(name, "PrPs")
}

// CamelCase returns the CamelCased name.
// If there is an interior underscore followed by a lower case letter,
// drop the underscore and convert the letter to upper case.
// There is a remote possibility of this rewrite causing a name collision,
// but it's so remote we're prepared to pretend it's nonexistent - since the
// C++ generator lowercases names, it's extremely unlikely to have two fields
// with different capitalizations.
// In short, _my_field_name_2 becomes XMyFieldName_2.
func CamelCase(s string) string {
	if s == "" {
		return ""
	}
	t := make([]byte, 0, 32)
	i := 0
	if s[0] == '_' {
		// Need a capital letter; drop the '_'.
		t = append(t, 'X')
		i++
	}
	// Invariant: if the next letter is lower case, it must be converted
	// to upper case.
	// That is, we process a word at a time, where words are marked by _ or
	// upper case letter. Digits are treated as words.
	for ; i < len(s); i++ {
		c := s[i]
		if c == '_' && i+1 < len(s) && isASCIILower(s[i+1]) {
			continue // Skip the underscore in s.
		}
		if isASCIIDigit(c) {
			t = append(t, c)
			continue
		}
		// Assume we have a letter now - if not, it's a bogus identifier.
		// The next word is a sequence of characters that must start upper case.
		if isASCIILower(c) {
			c ^= ' ' // Make it a capital letter.
		}
		t = append(t, c) // Guaranteed not lower case.
		// Accept lower case sequence that follows.
		for i+1 < len(s) && isASCIILower(s[i+1]) {
			i++
			t = append(t, s[i])
		}
	}
	return string(t)
}

// Is c an ASCII lower-case letter?
func isASCIILower(c byte) bool {
	return 'a' <= c && c <= 'z'
}

// Is c an ASCII digit?
func isASCIIDigit(c byte) bool {
	return '0' <= c && c <= '9'
}

func SnakeCase(name string) string {
	buffer := NewBuffer()
	for i, r := range name {
		if unicode.IsUpper(r) {
			if i != 0 {
				buffer.Append('_')
			}
			buffer.Append(unicode.ToLower(r))
		} else {
			buffer.Append(r)
		}
	}
	return buffer.String()
}

type Buffer struct {
	*bytes.Buffer
}

func NewBuffer() *Buffer {
	return &Buffer{Buffer: new(bytes.Buffer)}
}

func (b *Buffer) Append(i interface{}) *Buffer {
	switch val := i.(type) {
	case int:
		b.append(strconv.Itoa(val))
	case int64:
		b.append(strconv.FormatInt(val, 10))
	case uint:
		b.append(strconv.FormatUint(uint64(val), 10))
	case uint64:
		b.append(strconv.FormatUint(val, 10))
	case string:
		b.append(val)
	case []byte:
		b.Write(val)
	case rune:
		b.WriteRune(val)
	}
	return b
}

func (b *Buffer) append(s string) *Buffer {
	b.WriteString(s)
	return b
}
